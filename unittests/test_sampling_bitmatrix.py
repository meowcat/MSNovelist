import sys
import os
sys.path.append(os.environ['MSNOVELIST_BASE'])

import unittest

import smiles_config as sc
import fp_management.fingerprinting as fpr
from fp_management import fingerprint_map as fpm
import fp_sampling.bitmatrix as spl
import tensorflow as tf
import numpy as np
import numpy.testing as np_testing
import pandas as pd
import sqlite3
import tempfile
import pickle
import pathlib

class BitmatrixSamplingTest(unittest.TestCase):
    
    def get_generator(self):
        return tf.random.experimental.Generator.from_seed(self.seed)
    
    def setUp(self):
        self.seed = 66


        # These stats have been adapted such that they have the form required
        # in the bitmatrix sampler (row 0 and 1 are the probabilities to sample
        # a One prediction for a Zero and One truth, respectively.)
        
        self.stats_ref = np.array([
        [0.04965889, 0.07853103, 0.1390382 , 0.03164488, 0.22323525,
            0.02053988, 0.15484893, 0.02245468, 0.00777316, 0.02622759],
        [0.8682724 , 0.90812576, 0.9872968 , 0.90505135, 0.9648014 ,
            0.6979352 , 0.9819981 , 0.763097  , 0.37632978, 0.95542455]
        ], dtype="float32")
        
                
        self.candidates = np.array([
            [1,1,1,1,1,1,1,1,1,1],
            [0,0,0,0,0,0,0,0,0,0],
            [1,1,1,1,1,0,0,0,0,0],
            [0,0,0,0,0,1,1,1,1,1],
            [0,1,0,1,0,1,0,1,0,1]
            ], dtype="float32")
    
        # This is the random matrix that gets generated by the first call
        # of the uniform sampler with seed 66
        self.ref_random = np.array(
        [[0.8007604 , 0.34483027, 0.30735934, 0.9700769 , 0.43336582,
        0.51829636, 0.8555572 , 0.21962428, 0.76091194, 0.04762888],
       [0.5131633 , 0.97339594, 0.33341944, 0.03152311, 0.28874612,
        0.58736026, 0.75669694, 0.7060174 , 0.5588795 , 0.40088904],
       [0.8377521 , 0.7651175 , 0.5402924 , 0.52445555, 0.8965409 ,
        0.4253844 , 0.6824161 , 0.17499602, 0.4163201 , 0.8321508 ],
       [0.313666  , 0.15126252, 0.23609889, 0.56451845, 0.44649565,
        0.41026497, 0.60833323, 0.50973356, 0.31043375, 0.07893777],
       [0.57783425, 0.16236854, 0.63097   , 0.7254863 , 0.8393048 ,
        0.89883757, 0.64980876, 0.0960505 , 0.06560767, 0.6030959 ]])
        
                
        ref_sampled = np.array(
            [[1., 1., 1., 0., 1., 1., 1., 1., 0., 1.],
       [0., 1., 0., 0., 0., 0., 0., 0., 0., 0.],
       [1., 1., 1., 1., 1., 0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0., 1., 1., 1., 1., 1.],
       [0., 1., 0., 1., 1., 0., 0., 1., 0., 1.]] )
        
    def test_get_sampler(self):
        '''
        Check if generating a sampler works correctly and the stats
        are the ones we know.

        Returns
        -------
        None.

        '''
        sf = spl.SamplerFactory(sc.config)
        sampler = sf.get_sampler()
        
    def test_tf_random(self):
        '''
        Check that random function consistently generates our reference random array

        Returns
        -------
        None.

        '''    

        tf_random = self.get_generator().uniform(self.candidates.shape, dtype="float32")

        self.assertTrue(
            np.all(np.isclose(self.ref_random, tf_random, atol=0.0001))
            )
        
                # check that this is reproducible and doesn't only work the first time
        tf_random = self.get_generator().uniform(self.candidates.shape, dtype="float32")

        self.assertTrue(
            np.all(np.isclose(self.ref_random, tf_random, atol=0.0001))
            )
    
    def test_tf_random_binary(self):
        '''
        Test random binary sampling

        Returns
        -------
        None.

        '''
        rbs = spl.BitmatrixRandomBinarySampler(
            self.stats_ref, 
            self.get_generator())
        # self.rbs = rbs
        # self.
        fp_sampled = rbs.sample(self.candidates)
        self.fp_sampled = fp_sampled
        
        # fp_all_1 = (self.ref_random[0,:] < rbs.bitmatrix_stats[0,:]).numpy().astype("float32")
        # fp_all_0 = (self.ref_random[1,:] > rbs.bitmatrix_stats[0,:]).numpy().astype("float32")
        
        # self.assertTrue(np.array_equiv(fp_sampled.numpy()[0,:], fp_all_0))
        # self.assertTrue(np.array_equiv(fp_sampled.numpy()[1,:], fp_all_1))
        
        

        ref_sampled = np.array(
            [[1., 1., 1., 0., 1., 1., 1., 1., 0., 1.],
            [0., 1., 0., 0., 0., 0., 0., 0., 0., 0.],
            [1., 1., 1., 1., 1., 0., 0., 0., 0., 0.],
            [0., 0., 0., 0., 0., 1., 1., 1., 1., 1.],
            [0., 1., 0., 1., 1., 0., 0., 1., 0., 1.]] 
            )
        
        np_testing.assert_allclose(fp_sampled[0,:], ref_sampled[0,:])
        #self.assertTrue(np.array_equal(fp_sampled[0,:], ref_sampled[0,:]))
        #self.assertTrue(True)
        

    def test_samplerfactory(self):

        # create a mock DB 
        db_filename = tempfile.mkstemp(suffix=".db")
        os.close(db_filename[0])
        db = sqlite3.connect(db_filename[1])
        cur = db.cursor()
        cur.execute("CREATE TABLE compounds (id integer primary key, grp char(128))")
        ids = range(10)
        folds = ['fold4', 'fold3', 'fold2', 'fold1', 'fold0' ] * 2
        folds[3] = "invalid"
        for id, fold in zip(ids, folds):
            cur.execute("INSERT INTO compounds VALUES(?, ?)", (id+1, fold))
        db.commit()
        db.close()
        # create a mock fingerprint pickle



        # 
        tp = spl.Bitmask.PREDICTED | spl.Bitmask.TRUTH | spl.Bitmask.TP
        fp = spl.Bitmask.PREDICTED | spl.Bitmask.FP
        tn = spl.Bitmask.TN
        fn = spl.Bitmask.TRUTH | spl.Bitmask.FN

        fp_bitmatrix = np.array([
            [tp, tp, tp, tp, tp, fn, tn, tn, fp, fp],
            [fn, fn, fn, tn, tn, tn, fp, fp, fp, fp],
            [fn, fn, fn, fn, fn, fp, fp, fp, fp, fp]
        #   [yy, oo, yy, oo, yy, yy, oo, yy, yy, yy] for fold 3 (yy = yes)
        ], dtype = 'uint8').transpose()

        # np.sum(spl.Bitmask.TP & fp_bitmatrix, axis=0) // spl.Bitmask.TP = [5, 0, 0]
        # np.sum(spl.Bitmask.FP & fp_bitmatrix, axis=0) // spl.Bitmask.FP = [2, 4, 5]
        # np.sum(spl.Bitmask.TN & fp_bitmatrix, axis=0) // spl.Bitmask.TN = [2, 3, 0]
        # np.sum(spl.Bitmask.FN & fp_bitmatrix, axis=0) // spl.Bitmask.FN = [1, 3, 5]

        pkl_filename = pathlib.Path(db_filename[1]).with_suffix(".pkl")
        with open(pkl_filename, 'wb') as f:
            pickle.dump(fp_bitmatrix, f)

        config = {
            'db_path_sampler': {'path': db_filename[1]},
            'cv_fold': '3'
        }

        n_fold3 = 7
        stats_fold3 = [
            { 'TP': 3, 'FP': 2, 'TN': 1, 'FN': 1 },
            { 'TP': 0, 'FP': 3, 'TN': 2, 'FN': 2 },
            { 'TP': 0, 'FP': 4, 'TN': 0, 'FN': 3 }
        ]
        samplerstats_fold3 = np.array([
            [2./3., .75],
            [0.6, 0],
            [1, 0 ]
        ]).transpose()

        sampler_factory = spl.SamplerFactory(config)
        sampler = sampler_factory.get_sampler()
        np.testing.assert_allclose(
            sampler.bitmatrix_stats.numpy(),
            samplerstats_fold3
        )








        


        # class SamplerFactory:
        # def __init__(self, config):
        # self.db_path = config['db_path_sampler']
        # self.bitmatrix_path = pathlib.Path(self.db_path["path"]).with_suffix(".pkl")
        # self.selected_fold = config['cv_fold']
        # self._loaded = False
        # self.db = None
        # self.ids = None
        # self.bitmatrix_data = None
        # self.bitmatrix_stats = None

if __name__ == '__main__':
    unittest.main()